# DBConnPool
design database connection pool by c++

一、使用数据库连接池目的
    在高并发情况下，如果每次操作数据库都需要连接数据库，操作完再释放连接，连接和释放这2个过程是非常耗费资源和时间的。为了避免频繁的连接和释放，使用数据库连接池。
二、实现数据库连接池的基本思路
    预先在内存中建立多个数据库连接对象，并把这些对象放入连接池中。需要操作数据库时，从连接池中取出连接，操作完再归还给连接池。
三、数据库连接池的总体设计
    1、通常情况下使用配置文件保存数据库连接信息
    2、自定义一个“连接”类Connection。把该连接类Connection放入容器中作为连接池。
    3、连接池的实现采用单例模式
    4、连接池的容器使用STL的queue实现。同时使用互斥锁保证队列的安全。
    5、采用生产者-消费者模型：生产者负责创建连接，消费者负责使用连接。考虑多线程竞争情况，使用条件变量和互斥锁实现线程安全。
    6、由于连接用完后是归还而不是释放，用智能指针来管理连接，用lamda表达式来实现连接归还的功能。（因为智能指针出作用域自动析构，且申明指针智能时可以指定删除器，方便自定义归还功能）
    
四、数据库连接池的详细设计
1、数据库连接类Connection的功能
1.1、创建/销毁数据库连接对象，提供增删改查操作，计算连接对象的空闲时间
2、数据库连接池类ConnectionPool的详细设计
2.1、连接池的参数设计
（1）初始连接数：
    连接池事先会准备一些连接备用。最小连接数需要根据实际情况不断测试决定，设置太多的话会出现很多空连接，浪费资源。
（2）最大连接参数：
    当并发请求太多了之后，初始量不够用了。这时候会根据需求创建更多的连接，但不能无限创建，因为考虑到资源浪费问题。
（3）最大空闲时间：
    当并发请求增多以后，连接数会变多。由于“归还”原因，这些连接不会被直接释放，而是归还到队列中。
    假设后面的并发请求没那么多，那么之前产生的多的连接会造成资源冗余浪费。需要我们设置一个最大空闲时间。如果在最大空闲时间内，该连接还没有被使用的话，就需要被回收掉，节约资源。
    考虑容器基于队列queue实现，当队头元素的存活时间都没超过最大空闲时间的话，后面的连接肯定也没超过该最大空闲时间。
2.2、连接池的主要功能
（1）创建一个连接池对象。（因为是一个单例模式）
（2）初始化连接数以及生产新连接（生产过程是连接池类内部多线程创建的，所以权限为private；另外需要定义一个连接数计算器，使用原子变量atomic，就不需要用互斥锁来保护该计数器了）
（3）从连接池中获取一个可用连接（消费过程是用户请求，权限为public；用完后归还到队列中）
（4）回收连接（通过定义一个扫描函数，获取每个连接的空闲时间，用于多余连接的释放）
（5）加载初始配置项，主要是数据库连接参数如用户名密码等（可选）




//c++11magicstatic特性：如果当变量在初始化的时候，并发同时进⻉声明语句，并发线程将会阻塞等待初始化结束。
classSingleton//懒汉模式
{
public:
~Singleton(){}
static Singleton& GetInstance()
{
static Singletoninstance;
returninstance;
}
private:
Singleton(){}//子类会调用父类的构造函数，但是父类构造函数为私有的，因此这种类无法被继承Singleton(constSingleton&){}Singleton&operator=(constSingleton&){}};//继承Singleton//g++Singleton.cpp-osingleton-std=c++11/*该版本具备版本5所有优点：1.利⻉静态局部变量特性，延迟加载；
2.利⻉静态局部变量特性，系统⻉动回收内存，⻉动调⻉析构函数；3.静态局部变量初始化时，没有new操作带来的cpu指令reorder操作；4.c++11静态局部变量初始化时，自带线程安全；*/  

    
    